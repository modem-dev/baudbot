#!/bin/bash
# Safe bash wrapper for baudbot_agent
# Blocks known-dangerous command patterns before execution.
# Install: /usr/local/bin/baudbot-safe-bash (root-owned, not writable by agent)
#
# This is defense-in-depth â€” the agent's instructions also prohibit these,
# but a successful injection might override soft instructions.
#
# NOTE: Avoid grep -P (Perl regex) â€” not available on all distros.
# Use grep -E (extended regex) or awk instead.

# Patterns that should NEVER be executed by the agent
COMMAND="$*"

block() {
  echo "ðŸš« BLOCKED by baudbot-safe-bash: $1" >&2
  echo "   Command: ${COMMAND:0:200}" >&2
  exit 137
}

# Fork bomb
if echo "$COMMAND" | grep -qE ':\(\)[[:space:]]*\{.*\|.*&.*\}'; then
  block "fork bomb"
fi

# rm -rf / or rm -rf /* (root filesystem deletion)
if echo "$COMMAND" | grep -qE 'rm[[:space:]]+(-[a-zA-Z]*f[a-zA-Z]*[[:space:]]+)?(-[a-zA-Z]*r[a-zA-Z]*[[:space:]]+)?(/[[:space:]]*$|/\*|/[[:space:]]+)'; then
  block "recursive delete of root filesystem"
fi
if echo "$COMMAND" | grep -qE 'rm[[:space:]]+(-[a-zA-Z]*r[a-zA-Z]*[[:space:]]+)?(-[a-zA-Z]*f[a-zA-Z]*[[:space:]]+)?(/[[:space:]]*$|/\*|/[[:space:]]+)'; then
  block "recursive delete of root filesystem"
fi

# dd writing to block devices
if echo "$COMMAND" | grep -qE 'dd[[:space:]]+.*of=/dev/(sd|vd|nvme|xvd)'; then
  block "dd write to block device"
fi

# mkfs on block devices
if echo "$COMMAND" | grep -qE 'mkfs[^a-zA-Z].*/dev/'; then
  block "mkfs on block device"
fi

# chmod 777 on sensitive paths
if echo "$COMMAND" | grep -qE 'chmod[[:space:]]+(-[a-zA-Z]*[[:space:]]+)?777[[:space:]]+(/|/etc|/home|/root|/var)'; then
  block "chmod 777 on sensitive path"
fi

# Curl/wget piped to shell
if echo "$COMMAND" | grep -qE '(curl|wget)[[:space:]]+.*\|[[:space:]]*(ba)?sh'; then
  block "piping download to shell"
fi

# Reverse shell patterns
if echo "$COMMAND" | grep -qE 'bash[[:space:]]+-i[[:space:]]+>[&|][[:space:]]*/dev/tcp/'; then
  block "reverse shell (bash /dev/tcp)"
fi
if echo "$COMMAND" | grep -qE 'nc[[:space:]]+(-[a-zA-Z]*[[:space:]]+)*[0-9]+.*-e[[:space:]]*(\/bin\/)?(ba)?sh'; then
  block "reverse shell (netcat)"
fi
if echo "$COMMAND" | grep -qE 'python[23]?[[:space:]]+-c.*socket.*connect.*subprocess'; then
  block "reverse shell (python)"
fi

# crontab modification (persistence)
if echo "$COMMAND" | grep -qE '(crontab[[:space:]]+-[erl]|echo.*>[[:space:]]*/etc/cron)'; then
  block "crontab modification"
fi

# Modifying /etc/passwd or /etc/shadow
if echo "$COMMAND" | grep -qE '>[[:space:]]*/etc/(passwd|shadow|sudoers)'; then
  block "write to system auth files"
fi

# SSH key injection to other users
# Can't use negative lookahead without grep -P, so match broadly then exclude our user
if echo "$COMMAND" | grep -qE '>[[:space:]]*/home/.*/.ssh/authorized_keys'; then
  if ! echo "$COMMAND" | grep -qE '>[[:space:]]*/home/baudbot_agent/.ssh/authorized_keys'; then
    block "SSH key injection to another user"
  fi
fi
if echo "$COMMAND" | grep -qE '>[[:space:]]*/root/.ssh/authorized_keys'; then
  block "SSH key injection to root"
fi

# If none of the blockers fired, execute normally
exec /bin/bash -c "$COMMAND"
