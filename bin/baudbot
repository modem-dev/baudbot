#!/bin/bash
# Baudbot CLI dispatcher
# Routes subcommands to internal scripts. Installed as /usr/local/bin/baudbot.
#
# Usage: baudbot <command> [options]

set -euo pipefail

# Find the baudbot source root. Resolution order:
# 1. BAUDBOT_ROOT env var (explicit override)
# 2. Resolve from this script's real location (follow symlinks, then ../)
if [ -z "${BAUDBOT_ROOT:-}" ]; then
  SCRIPT="$0"
  # Follow symlinks to find the real script location
  while [ -L "$SCRIPT" ]; do
    DIR="$(cd "$(dirname "$SCRIPT")" && pwd)"
    SCRIPT="$(readlink "$SCRIPT")"
    # Handle relative symlinks
    [[ "$SCRIPT" != /* ]] && SCRIPT="$DIR/$SCRIPT"
  done
  BAUDBOT_ROOT="$(cd "$(dirname "$SCRIPT")/.." && pwd)"
fi

# Colors (disabled if not a terminal)
if [ -t 1 ]; then
  BOLD='\033[1m'
  RESET='\033[0m'
else
  BOLD='' RESET=''
fi

version() {
  if [ -f "$BAUDBOT_ROOT/package.json" ]; then
    grep '"version"' "$BAUDBOT_ROOT/package.json" | head -1 | sed 's/.*: *"\(.*\)".*/\1/'
  else
    echo "unknown"
  fi
}

usage() {
  echo -e "${BOLD}baudbot${RESET} — hardened infrastructure for always-on AI agents"
  echo ""
  echo -e "${BOLD}Usage:${RESET} baudbot <command> [options]"
  echo ""
  echo -e "${BOLD}Lifecycle:${RESET}"
  echo "  start          Start the agent (systemd, or --direct for foreground)"
  echo "  stop           Stop the agent"
  echo "  restart        Restart the agent"
  echo "  status         Show agent status"
  echo "  logs           Tail agent logs"
  echo "  attach         Attach to tmux; falls back to pi session (name/id). Use --pi to force"
  echo "  sessions       List agent tmux and pi sessions (name → id)"
  echo ""
  echo -e "${BOLD}Setup:${RESET}"
  echo "  setup          One-time system setup (user, deps, firewall, systemd)"
  echo "  config         Interactive secrets and config setup"
  echo "  deploy         Deploy source + config to agent runtime"
  echo ""
  echo -e "${BOLD}Operations:${RESET}"
  echo "  doctor         Health check (perms, firewall, secrets, deps)"
  echo "  audit          Security posture audit"
  echo "  test           Run test suite"
  echo "  update         Build/test in temp checkout, publish git-free release, deploy"
  echo "  rollback       Re-deploy previous (or specified) git-free release snapshot"
  echo "  uninstall      Remove everything"
  echo ""
  echo -e "${BOLD}Options:${RESET}"
  echo "  --version      Show version"
  echo "  --help, -h     Show this help"
}

require_root() {
  if [ "$(id -u)" -ne 0 ]; then
    echo "❌ baudbot $1 requires root. Run: sudo baudbot $1"
    exit 1
  fi
}

# Detect systemd
has_systemd() {
  command -v systemctl &>/dev/null && [ -d /run/systemd/system ]
}

pi_control_dir() {
  local agent_user="${1:-baudbot_agent}"
  echo "/home/$agent_user/.pi/session-control"
}

pi_alias_to_uuid() {
  local alias_path="$1"
  local target

  target=$(readlink "$alias_path" 2>/dev/null || true)
  target=$(basename "$target")
  target="${target%.sock}"

  if [ -n "$target" ]; then
    echo "$target"
    return 0
  fi

  return 1
}

resolve_pi_session_id() {
  local agent_user="$1"
  local query="${2:-}"
  local dir
  local first_sock
  local matches
  local count

  dir=$(pi_control_dir "$agent_user")
  [ -d "$dir" ] || return 1

  if [ -z "$query" ]; then
    if [ -L "$dir/control-agent.alias" ]; then
      pi_alias_to_uuid "$dir/control-agent.alias"
      return 0
    fi

    first_sock=$(find "$dir" -maxdepth 1 -type s -name '*.sock' -printf '%f\n' 2>/dev/null | sort | head -1)
    if [ -n "$first_sock" ]; then
      echo "${first_sock%.sock}"
      return 0
    fi

    return 1
  fi

  # Exact UUID/socket name.
  if [ -S "$dir/$query.sock" ]; then
    echo "$query"
    return 0
  fi

  # Named alias format used by pi extensions (e.g. control-agent.alias).
  if [ -L "$dir/$query.alias" ]; then
    pi_alias_to_uuid "$dir/$query.alias"
    return 0
  fi

  # Back-compat alias format (<name>.sock symlink).
  if [ -L "$dir/$query.sock" ]; then
    pi_alias_to_uuid "$dir/$query.sock"
    return 0
  fi

  # Unique UUID prefix.
  matches=$(find "$dir" -maxdepth 1 -type s -name "$query*.sock" -printf '%f\n' 2>/dev/null | sort)
  count=$(echo "$matches" | grep -c . || true)
  if [ "$count" -eq 1 ]; then
    echo "${matches%.sock}"
    return 0
  fi
  if [ "$count" -gt 1 ]; then
    echo "❌ Multiple pi sessions match '$query'. Use full UUID or alias from: baudbot sessions" >&2
    return 2
  fi

  return 1
}

case "${1:-}" in
  start)
    shift
    if [ "${1:-}" = "--direct" ]; then
      # Foreground mode: run start.sh directly (for dev/CI/debugging)
      shift
      require_root "start --direct"
      exec sudo -u baudbot_agent "$BAUDBOT_ROOT/start.sh" "$@"
    else
      require_root "start"
      if has_systemd; then
        exec systemctl start baudbot "$@"
      else
        echo "systemd not available. Use: baudbot start --direct"
        exit 1
      fi
    fi
    ;;

  stop)
    shift
    require_root "stop"
    if has_systemd; then
      exec systemctl stop baudbot "$@"
    else
      echo "systemd not available. Kill the agent process manually."
      exit 1
    fi
    ;;

  restart)
    shift
    require_root "restart"
    if has_systemd; then
      exec systemctl restart baudbot "$@"
    else
      echo "systemd not available."
      exit 1
    fi
    ;;

  status)
    shift
    if has_systemd && systemctl is-enabled baudbot &>/dev/null; then
      exec systemctl status baudbot "$@"
    else
      # Fallback: check if baudbot_agent has pi running
      if pgrep -u baudbot_agent -f "pi --session-control" &>/dev/null; then
        echo "baudbot is running (no systemd unit)"
        pgrep -u baudbot_agent -af "pi --session-control"
      else
        echo "baudbot is not running"
      fi
    fi
    ;;

  logs)
    shift
    if has_systemd && systemctl is-enabled baudbot &>/dev/null; then
      exec journalctl -u baudbot -f "$@"
    else
      echo "No systemd unit. Check tmux sessions:"
      echo "  sudo -u baudbot_agent tmux ls"
    fi
    ;;

  sessions)
    shift
    require_root "sessions"
    AGENT_USER="baudbot_agent"
    echo -e "${BOLD}tmux sessions:${RESET}"
    if sudo -u "$AGENT_USER" tmux ls 2>/dev/null; then
      :
    else
      echo "  (none)"
    fi
    echo ""
    echo -e "${BOLD}pi sessions:${RESET}"
    PI_CONTROL_DIR="$(pi_control_dir "$AGENT_USER")"
    if [ -d "$PI_CONTROL_DIR" ]; then
      found=0
      declare -A ALIASES

      # New alias format: <name>.alias -> <uuid>.sock
      for alias in "$PI_CONTROL_DIR"/*.alias; do
        [ -L "$alias" ] || continue
        alias_name=$(basename "$alias" .alias)
        alias_uuid=$(pi_alias_to_uuid "$alias" || true)
        [ -n "$alias_uuid" ] && ALIASES[$alias_uuid]="$alias_name"
      done

      # Back-compat alias format: <name>.sock symlink -> <uuid>.sock
      for alias in "$PI_CONTROL_DIR"/*.sock; do
        [ -L "$alias" ] || continue
        alias_name=$(basename "$alias" .sock)
        alias_uuid=$(pi_alias_to_uuid "$alias" || true)
        [ -n "$alias_uuid" ] && ALIASES[$alias_uuid]="$alias_name"
      done

      # Real socket files are UUIDs.
      for sock in "$PI_CONTROL_DIR"/*.sock; do
        [ -S "$sock" ] || continue
        [ -L "$sock" ] && continue

        sess_id=$(basename "$sock" .sock)
        name="${ALIASES[$sess_id]:-}"

        status="stopped (stale)"
        if sudo -u "$AGENT_USER" bash -c "python3 -c \"import socket; s=socket.socket(socket.AF_UNIX); s.settimeout(0.3); s.connect('$sock'); s.close()\" 2>/dev/null" 2>/dev/null; then
          status="running"
        fi

        if [ -n "$name" ]; then
          echo "  $name ($sess_id) [$status]"
        else
          echo "  $sess_id [$status]"
        fi
        found=$((found + 1))
      done

      if [ "$found" -eq 0 ]; then
        echo "  (none)"
      fi
    else
      echo "  (no session-control directory)"
    fi
    ;;

  attach)
    shift
    require_root "attach"
    AGENT_USER="baudbot_agent"
    AGENT_HOME="/home/$AGENT_USER"

    ATTACH_MODE="auto"
    TARGET=""
    while [ "$#" -gt 0 ]; do
      case "$1" in
        --pi)
          ATTACH_MODE="pi"
          shift
          ;;
        --tmux)
          ATTACH_MODE="tmux"
          shift
          ;;
        -h|--help)
          echo "Usage: sudo baudbot attach [--pi|--tmux] [session-name|session-id]"
          echo ""
          echo "Examples:"
          echo "  sudo baudbot attach                  # tmux first, else control-agent pi session"
          echo "  sudo baudbot attach --pi control-agent"
          echo "  sudo baudbot attach --pi <uuid>"
          echo "  sudo baudbot attach --tmux baudbot"
          exit 0
          ;;
        *)
          if [ -n "$TARGET" ]; then
            echo "❌ Too many arguments for attach"
            exit 1
          fi
          TARGET="$1"
          shift
          ;;
      esac
    done

    attach_tmux_session() {
      local tmux_target="$1"
      echo "Attaching to tmux session: $tmux_target"
      echo "Detach with: Ctrl+b, d"
      echo ""
      exec sudo -u "$AGENT_USER" tmux attach-session -t "$tmux_target"
    }

    attach_pi_session() {
      local pi_target="$1"
      echo "Attaching to pi session: $pi_target"
      echo "Detach with: Ctrl+C twice"
      echo ""
      exec sudo -u "$AGENT_USER" bash -lc "export PATH='$AGENT_HOME/.varlock/bin:$AGENT_HOME/opt/node-v22.14.0-linux-x64/bin':\$PATH; cd ~; pi --session '$pi_target'"
    }

    choose_tmux_target() {
      local requested="${1:-}"
      local first

      if [ -n "$requested" ]; then
        if sudo -u "$AGENT_USER" tmux has-session -t "$requested" 2>/dev/null; then
          echo "$requested"
          return 0
        fi
        return 1
      fi

      first=$(sudo -u "$AGENT_USER" tmux ls -F '#{session_name}' 2>/dev/null | head -1)
      [ -n "$first" ] || return 1
      echo "$first"
      return 0
    }

    choose_pi_target() {
      local requested="${1:-}"
      local resolved

      if ! resolved=$(resolve_pi_session_id "$AGENT_USER" "$requested"); then
        return 1
      fi

      [ -n "$resolved" ] || return 1
      echo "$resolved"
      return 0
    }

    if [ "$ATTACH_MODE" = "tmux" ]; then
      if tmux_target=$(choose_tmux_target "$TARGET"); then
        attach_tmux_session "$tmux_target"
      fi
      echo "❌ tmux session not found. See: sudo baudbot sessions"
      exit 1
    fi

    if [ "$ATTACH_MODE" = "pi" ]; then
      if pi_target=$(choose_pi_target "$TARGET"); then
        attach_pi_session "$pi_target"
      fi
      echo "❌ pi session not found. See: sudo baudbot sessions"
      exit 1
    fi

    # Auto mode: prefer tmux if available/targeted, otherwise fall back to pi.
    if tmux_target=$(choose_tmux_target "$TARGET"); then
      attach_tmux_session "$tmux_target"
    fi

    if pi_target=$(choose_pi_target "$TARGET"); then
      attach_pi_session "$pi_target"
    fi

    echo "❌ No matching tmux/pi session found. See: sudo baudbot sessions"
    exit 1
    ;;

  setup)
    shift
    require_root "setup"
    exec "$BAUDBOT_ROOT/setup.sh" "$@"
    ;;

  config)
    shift
    exec "$BAUDBOT_ROOT/bin/config.sh" "$@"
    ;;

  deploy)
    shift
    require_root "deploy"
    exec "$BAUDBOT_ROOT/bin/deploy.sh" "$@"
    ;;

  audit)
    shift
    exec "$BAUDBOT_ROOT/bin/security-audit.sh" "$@"
    ;;

  test)
    shift
    exec "$BAUDBOT_ROOT/bin/test.sh" "$@"
    ;;

  update)
    shift
    require_root "update"
    exec "$BAUDBOT_ROOT/bin/update-release.sh" "$@"
    ;;

  rollback)
    shift
    require_root "rollback"
    exec "$BAUDBOT_ROOT/bin/rollback-release.sh" "$@"
    ;;

  uninstall)
    shift
    require_root "uninstall"
    exec "$BAUDBOT_ROOT/bin/uninstall.sh" "$@"
    ;;

  doctor)
    shift
    exec "$BAUDBOT_ROOT/bin/doctor.sh" "$@"
    ;;

  --version|-v)
    echo "baudbot $(version)"
    ;;

  --help|-h|"")
    usage
    ;;

  *)
    echo "Unknown command: $1"
    echo ""
    usage
    exit 1
    ;;
esac
