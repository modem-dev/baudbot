#!/bin/bash
# Baudbot CLI dispatcher
# Routes subcommands to internal scripts. Installed as /usr/local/bin/baudbot.
#
# Usage: baudbot <command> [options]

set -euo pipefail

# Find the baudbot source root. Resolution order:
# 1. BAUDBOT_ROOT env var (explicit override)
# 2. Resolve from this script's real location (follow symlinks, then ../)
if [ -z "${BAUDBOT_ROOT:-}" ]; then
  SCRIPT="$0"
  # Follow symlinks to find the real script location
  while [ -L "$SCRIPT" ]; do
    DIR="$(cd "$(dirname "$SCRIPT")" && pwd)"
    SCRIPT="$(readlink "$SCRIPT")"
    # Handle relative symlinks
    [[ "$SCRIPT" != /* ]] && SCRIPT="$DIR/$SCRIPT"
  done

  CANDIDATE_ROOT="$(cd "$(dirname "$SCRIPT")/.." && pwd)"
  if [ -f "$CANDIDATE_ROOT/bin/baudbot" ] && [ -f "$CANDIDATE_ROOT/package.json" ]; then
    BAUDBOT_ROOT="$CANDIDATE_ROOT"
  elif [ -d /opt/baudbot/current/bin ]; then
    BAUDBOT_ROOT="$(readlink -f /opt/baudbot/current 2>/dev/null || echo /opt/baudbot/current)"
  else
    BAUDBOT_ROOT="$CANDIDATE_ROOT"
  fi
fi

json_get_string_or_empty() {
  local file="$1"
  local key="$2"
  [ -r "$file" ] || return 0
  command -v jq >/dev/null 2>&1 || return 0
  jq -er --arg k "$key" 'if (type == "object") and has($k) and (.[$k] | type == "string") then .[$k] else empty end' "$file" 2>/dev/null || true
}

json_get_string_stdin_or_empty() {
  local key="$1"
  command -v jq >/dev/null 2>&1 || return 0
  jq -er --arg k "$key" 'if (type == "object") and has($k) and (.[$k] | type == "string") then .[$k] else empty end' 2>/dev/null || true
}

# Colors (disabled if not a terminal)
if [ -t 1 ]; then
  BOLD='\033[1m'
  DIM='\033[2m'
  CYAN='\033[0;36m'
  YELLOW='\033[0;33m'
  GREEN='\033[0;32m'
  RESET='\033[0m'
else
  BOLD='' DIM='' CYAN='' YELLOW='' GREEN='' RESET=''
fi

version() {
  local package_json="$BAUDBOT_ROOT/package.json"
  local pkg_version=""

  if [ -f "$package_json" ]; then
    pkg_version="$(json_get_string_or_empty "$package_json" "version")"
    [ -n "$pkg_version" ] && echo "$pkg_version" && return 0
  fi

  echo "unknown"
}

version_sha() {
  local sha=""
  local release_target=""
  local version_file=""

  # Source checkout path (git repo)
  if command -v git >/dev/null 2>&1; then
    sha="$(git -C "$BAUDBOT_ROOT" rev-parse --short=7 HEAD 2>/dev/null || true)"
    if [ -n "$sha" ]; then
      echo "$sha"
      return 0
    fi
  fi

  # /opt/baudbot/releases/<sha>
  if printf '%s\n' "$BAUDBOT_ROOT" | grep -Eq '/releases/[0-9a-f]{7,40}$'; then
    sha="${BAUDBOT_ROOT##*/}"
    echo "${sha:0:7}"
    return 0
  fi

  # /opt/baudbot/current -> /opt/baudbot/releases/<sha>
  release_target="$(readlink -f /opt/baudbot/current 2>/dev/null || true)"
  if printf '%s\n' "$release_target" | grep -Eq '/releases/[0-9a-f]{7,40}$'; then
    sha="${release_target##*/}"
    echo "${sha:0:7}"
    return 0
  fi

  # Runtime metadata fallback
  version_file="/home/${BAUDBOT_AGENT_USER:-baudbot_agent}/.pi/agent/baudbot-version.json"
  if [ -r "$version_file" ]; then
    sha="$(json_get_string_or_empty "$version_file" "sha")"
    [ -n "$sha" ] && echo "${sha:0:7}" && return 0
  fi

  echo ""
}

version_display() {
  local base
  local sha

  base="$(version)"
  sha="$(version_sha)"

  if [ -n "$sha" ]; then
    echo "$base ($sha)"
  else
    echo "$base"
  fi
}

usage() {
  echo -e "${BOLD}baudbot${RESET} — hardened infrastructure for always-on AI agents"
  echo ""
  echo -e "${BOLD}Usage:${RESET} baudbot <command> [options]"
  echo ""
  echo -e "${BOLD}Lifecycle:${RESET}"
  echo "  start          Start the agent (systemd, or --direct for foreground)"
  echo "  stop           Stop the agent"
  echo "  restart        Restart the agent"
  echo "  status         Show agent status + deployed version + broker connection"
  echo "  logs           Tail agent logs"
  echo "  attach         Attach to control-agent by default; supports --pi/--tmux"
  echo "  sessions       List agent tmux and pi sessions (name → id)"
  echo ""
  echo -e "${BOLD}Setup:${RESET}"
  echo "  install        Bootstrap install from GitHub (download script, then escalate)"
  echo "  setup          One-time system setup (user, deps, firewall, systemd; --experimental enables risky integrations)"
  echo "  config         Interactive secrets and config setup"
  echo "  env            Manage env vars and backend source (set/get/sync/backend)"
  echo "  deploy         Deploy source + config to agent runtime"
  echo "  broker         Slack broker commands (register workspace linkage)"
  echo ""
  echo -e "${BOLD}Operations:${RESET}"
  echo "  doctor         Health check (perms, firewall, secrets, deps)"
  echo "  audit          Security posture audit"
  echo "  version        Show baudbot CLI version (+ git SHA when available)"
  echo "  test           Run test suite"
  echo "  update         Build/test in temp checkout, publish git-free release, deploy"
  echo "  rollback       Re-deploy previous (or specified) git-free release snapshot"
  echo "  uninstall      Remove everything"
  echo ""
  echo -e "${BOLD}Options:${RESET}"
  echo "  --version      Show version (+ git SHA when available)"
  echo "  --help, -h     Show this help"
}

require_root() {
  if [ "$(id -u)" -ne 0 ]; then
    echo "❌ baudbot $1 requires root. Run: sudo baudbot $1"
    exit 1
  fi
}

resolve_user_home() {
  local user="$1"
  local passwd_line=""

  if [ -z "$user" ]; then
    return 1
  fi

  passwd_line="$(getent passwd "$user" 2>/dev/null || true)"
  if [ -n "$passwd_line" ]; then
    echo "$passwd_line" | cut -d: -f6
    return 0
  fi

  # Fallback for environments without getent or missing passwd entry
  if [ -d "/home/$user" ]; then
    echo "/home/$user"
    return 0
  fi

  return 1
}

resolve_node_bin() {
  # 1) Standard PATH lookup
  if command -v node >/dev/null 2>&1; then
    command -v node
    return 0
  fi

  # 2) Common user-managed Node installs (sudo secure_path may hide these)
  local user_home=""
  if [ -n "${SUDO_USER:-}" ] && [ "${SUDO_USER}" != "root" ]; then
    user_home="$(resolve_user_home "$SUDO_USER" || true)"
  fi
  if [ -z "$user_home" ]; then
    user_home="${HOME:-}"
  fi

  local candidate=""
  for candidate in \
    "$user_home/.local/share/mise/shims/node" \
    "$user_home/.local/bin/node" \
    "$user_home/opt/node-v22.14.0-linux-x64/bin/node" \
    /home/baudbot_agent/opt/node-v22.14.0-linux-x64/bin/node \
    "$user_home"/opt/node-v*-linux-x64/bin/node; do
    # If the glob didn't expand, skip the literal pattern.
    case "$candidate" in
      *\**)
        continue
        ;;
    esac

    if [ -x "$candidate" ]; then
      echo "$candidate"
      return 0
    fi
  done

  return 1
}

escalate_prefix() {
  if [ "$(id -u)" -eq 0 ]; then
    return 0
  fi

  if command -v sudo >/dev/null 2>&1; then
    echo "sudo"
    return 0
  fi

  if command -v doas >/dev/null 2>&1; then
    echo "doas"
    return 0
  fi

  echo ""
  return 1
}

download_file() {
  local url="$1"
  local dest="$2"

  if command -v curl >/dev/null 2>&1; then
    curl -fsSL "$url" -o "$dest"
    return 0
  fi

  if command -v wget >/dev/null 2>&1; then
    wget -q "$url" -O "$dest"
    return 0
  fi

  echo "❌ install requires curl or wget to download installer"
  exit 1
}

bootstrap_install() {
  local install_url="${BAUDBOT_INSTALL_SCRIPT_URL:-https://raw.githubusercontent.com/modem-dev/baudbot/main/install.sh}"
  local install_script
  local escalator=""

  install_script="$(mktemp /tmp/baudbot-install.XXXXXX.sh)"
  trap 'rm -f "$install_script"' RETURN

  download_file "$install_url" "$install_script"
  chmod 700 "$install_script"

  echo "Downloaded installer: $install_script"

  if [ "$(id -u)" -eq 0 ]; then
    bash "$install_script" "$@"
    return 0
  fi

  escalator="$(escalate_prefix || true)"
  if [ -z "$escalator" ]; then
    echo "❌ install requires root privileges but no sudo/doas was found"
    echo "Re-run as root, or install sudo/doas first."
    return 1
  fi

  echo "Escalating with $escalator for system setup..."
  if [ "$escalator" = "sudo" ]; then
    sudo --preserve-env=BAUDBOT_PI_VERSION bash "$install_script" "$@"
  else
    # doas has no portable preserve-env flag; pass explicitly when set.
    if [ -n "${BAUDBOT_PI_VERSION:-}" ]; then
      doas env BAUDBOT_PI_VERSION="$BAUDBOT_PI_VERSION" bash "$install_script" "$@"
    else
      doas bash "$install_script" "$@"
    fi
  fi
}

RUNTIME_HELPER="$BAUDBOT_ROOT/bin/lib/baudbot-runtime.sh"
if [ -f "$RUNTIME_HELPER" ]; then
  # shellcheck source=bin/lib/baudbot-runtime.sh
  source "$RUNTIME_HELPER"
else
  has_systemd() { command -v systemctl &>/dev/null && [ -d /run/systemd/system ]; }
  cmd_status() { echo "❌ Missing CLI runtime helper. Run: sudo baudbot deploy"; exit 1; }
  cmd_logs() { echo "❌ Missing CLI runtime helper. Run: sudo baudbot deploy"; exit 1; }
  cmd_sessions() { echo "❌ Missing CLI runtime helper. Run: sudo baudbot deploy"; exit 1; }
  cmd_attach() { echo "❌ Missing CLI runtime helper. Run: sudo baudbot deploy"; exit 1; }
fi

case "${1:-}" in
  install)
    shift
    bootstrap_install "$@"
    ;;

  start)
    shift
    if [ "${1:-}" = "--direct" ]; then
      # Foreground mode: run start.sh directly (for dev/CI/debugging)
      shift
      require_root "start --direct"
      exec sudo -u baudbot_agent "$BAUDBOT_ROOT/start.sh" "$@"
    else
      require_root "start"
      if has_systemd; then
        exec systemctl start baudbot "$@"
      else
        echo "systemd not available. Use: baudbot start --direct"
        exit 1
      fi
    fi
    ;;

  stop)
    shift
    require_root "stop"
    if has_systemd; then
      exec systemctl stop baudbot "$@"
    else
      echo "systemd not available. Kill the agent process manually."
      exit 1
    fi
    ;;

  restart)
    shift
    require_root "restart"
    if has_systemd; then
      exec systemctl restart baudbot "$@"
    else
      echo "systemd not available."
      exit 1
    fi
    ;;

  status)
    shift
    cmd_status "$@"
    ;;

  logs)
    shift
    cmd_logs "$@"
    ;;

  sessions)
    shift
    cmd_sessions "$@"
    ;;

  attach)
    shift
    cmd_attach "$@"
    ;;

  setup)
    shift
    if [ "${1:-}" = "--slack-broker" ]; then
      shift
      require_root "broker register"
      echo "⚠️  'baudbot setup --slack-broker' is deprecated. Use: sudo baudbot broker register"
      NODE_BIN="$(resolve_node_bin || true)"
      if [ -z "$NODE_BIN" ]; then
        echo "❌ Could not find node runtime for broker registration."
        echo "   Install Node for root/sudo PATH or deploy with an embedded Node path."
        exit 1
      fi
      exec "$NODE_BIN" "$BAUDBOT_ROOT/bin/broker-register.mjs" "$@"
    fi
    require_root "setup"
    exec "$BAUDBOT_ROOT/setup.sh" "$@"
    ;;

  config)
    shift
    exec "$BAUDBOT_ROOT/bin/config.sh" "$@"
    ;;

  env)
    shift
    exec "$BAUDBOT_ROOT/bin/env.sh" "$@"
    ;;

  broker)
    shift
    case "${1:-}" in
      register)
        shift
        require_root "broker register"
        NODE_BIN="$(resolve_node_bin || true)"
        if [ -z "$NODE_BIN" ]; then
          echo "❌ Could not find node runtime for broker registration."
          echo "   Install Node for root/sudo PATH or deploy with an embedded Node path."
          exit 1
        fi
        exec "$NODE_BIN" "$BAUDBOT_ROOT/bin/broker-register.mjs" "$@"
        ;;
      --help|-h|"")
        echo "Usage: sudo baudbot broker register [--broker-url URL] [--workspace-id ID] [--auth-code CODE] [-v|--verbose]"
        ;;
      *)
        echo "Unknown broker subcommand: ${1:-}"
        echo "Usage: sudo baudbot broker register [--broker-url URL] [--workspace-id ID] [--auth-code CODE] [-v|--verbose]"
        exit 1
        ;;
    esac
    ;;

  deploy)
    shift
    require_root "deploy"
    exec "$BAUDBOT_ROOT/bin/deploy.sh" "$@"
    ;;

  audit)
    shift
    exec "$BAUDBOT_ROOT/bin/security-audit.sh" "$@"
    ;;

  test)
    shift
    exec "$BAUDBOT_ROOT/bin/test.sh" "$@"
    ;;

  update)
    shift
    require_root "update"
    exec "$BAUDBOT_ROOT/bin/update-release.sh" "$@"
    ;;

  rollback)
    shift
    require_root "rollback"
    exec "$BAUDBOT_ROOT/bin/rollback-release.sh" "$@"
    ;;

  uninstall)
    shift
    require_root "uninstall"
    exec "$BAUDBOT_ROOT/bin/uninstall.sh" "$@"
    ;;

  doctor)
    shift
    exec "$BAUDBOT_ROOT/bin/doctor.sh" "$@"
    ;;

  version)
    shift
    echo "baudbot $(version_display)"
    ;;

  --version|-v)
    echo "baudbot $(version_display)"
    ;;

  --help|-h|"")
    usage
    ;;

  *)
    echo "Unknown command: $1"
    echo ""
    usage
    exit 1
    ;;
esac
