#!/bin/bash
# Baudbot CLI dispatcher
# Routes subcommands to internal scripts. Installed as /usr/local/bin/baudbot.
#
# Usage: baudbot <command> [options]

set -euo pipefail

# Find the baudbot source root. Resolution order:
# 1. BAUDBOT_ROOT env var (explicit override)
# 2. Resolve from this script's real location (follow symlinks, then ../)
if [ -z "${BAUDBOT_ROOT:-}" ]; then
  SCRIPT="$0"
  # Follow symlinks to find the real script location
  while [ -L "$SCRIPT" ]; do
    DIR="$(cd "$(dirname "$SCRIPT")" && pwd)"
    SCRIPT="$(readlink "$SCRIPT")"
    # Handle relative symlinks
    [[ "$SCRIPT" != /* ]] && SCRIPT="$DIR/$SCRIPT"
  done
  BAUDBOT_ROOT="$(cd "$(dirname "$SCRIPT")/.." && pwd)"
fi

# Colors (disabled if not a terminal)
if [ -t 1 ]; then
  BOLD='\033[1m'
  DIM='\033[2m'
  CYAN='\033[0;36m'
  YELLOW='\033[0;33m'
  GREEN='\033[0;32m'
  RESET='\033[0m'
else
  BOLD='' DIM='' CYAN='' YELLOW='' GREEN='' RESET=''
fi

version() {
  if [ -f "$BAUDBOT_ROOT/package.json" ]; then
    grep '"version"' "$BAUDBOT_ROOT/package.json" | head -1 | sed 's/.*: *"\(.*\)".*/\1/'
  else
    echo "unknown"
  fi
}

usage() {
  echo -e "${BOLD}baudbot${RESET} — hardened infrastructure for always-on AI agents"
  echo ""
  echo -e "${BOLD}Usage:${RESET} baudbot <command> [options]"
  echo ""
  echo -e "${BOLD}Lifecycle:${RESET}"
  echo "  start          Start the agent (systemd, or --direct for foreground)"
  echo "  stop           Stop the agent"
  echo "  restart        Restart the agent"
  echo "  status         Show agent status + deployed version"
  echo "  logs           Tail agent logs"
  echo "  attach         Attach to control-agent by default; supports --pi/--tmux"
  echo "  sessions       List agent tmux and pi sessions (name → id)"
  echo ""
  echo -e "${BOLD}Setup:${RESET}"
  echo "  install        Bootstrap install from GitHub (download script, then escalate)"
  echo "  setup          One-time system setup (user, deps, firewall, systemd)"
  echo "  config         Interactive secrets and config setup"
  echo "  deploy         Deploy source + config to agent runtime"
  echo "  broker         Slack broker commands (register workspace linkage)"
  echo ""
  echo -e "${BOLD}Operations:${RESET}"
  echo "  doctor         Health check (perms, firewall, secrets, deps)"
  echo "  audit          Security posture audit"
  echo "  test           Run test suite"
  echo "  update         Build/test in temp checkout, publish git-free release, deploy"
  echo "  rollback       Re-deploy previous (or specified) git-free release snapshot"
  echo "  uninstall      Remove everything"
  echo ""
  echo -e "${BOLD}Options:${RESET}"
  echo "  --version      Show version"
  echo "  --help, -h     Show this help"
}

require_root() {
  if [ "$(id -u)" -ne 0 ]; then
    echo "❌ baudbot $1 requires root. Run: sudo baudbot $1"
    exit 1
  fi
}

escalate_prefix() {
  if [ "$(id -u)" -eq 0 ]; then
    return 0
  fi

  if command -v sudo >/dev/null 2>&1; then
    echo "sudo"
    return 0
  fi

  if command -v doas >/dev/null 2>&1; then
    echo "doas"
    return 0
  fi

  echo ""
  return 1
}

download_file() {
  local url="$1"
  local dest="$2"

  if command -v curl >/dev/null 2>&1; then
    curl -fsSL "$url" -o "$dest"
    return 0
  fi

  if command -v wget >/dev/null 2>&1; then
    wget -q "$url" -O "$dest"
    return 0
  fi

  echo "❌ install requires curl or wget to download installer"
  exit 1
}

bootstrap_install() {
  local install_url="${BAUDBOT_INSTALL_SCRIPT_URL:-https://raw.githubusercontent.com/modem-dev/baudbot/main/install.sh}"
  local install_script
  local escalator=""

  install_script="$(mktemp /tmp/baudbot-install.XXXXXX.sh)"
  trap 'rm -f "$install_script"' RETURN

  download_file "$install_url" "$install_script"
  chmod 700 "$install_script"

  echo "Downloaded installer: $install_script"

  if [ "$(id -u)" -eq 0 ]; then
    bash "$install_script" "$@"
    return 0
  fi

  escalator="$(escalate_prefix || true)"
  if [ -z "$escalator" ]; then
    echo "❌ install requires root privileges but no sudo/doas was found"
    echo "Re-run as root, or install sudo/doas first."
    return 1
  fi

  echo "Escalating with $escalator for system setup..."
  "$escalator" bash "$install_script" "$@"
}

# Detect systemd
has_systemd() {
  command -v systemctl &>/dev/null && [ -d /run/systemd/system ]
}

print_deployed_version() {
  local agent_user="${BAUDBOT_AGENT_USER:-baudbot_agent}"
  local version_file="/home/$agent_user/.pi/agent/baudbot-version.json"
  local version_json=""
  local short=""
  local sha=""
  local branch=""
  local deployed_at=""
  local line=""

  if [ -r "$version_file" ]; then
    version_json="$(cat "$version_file" 2>/dev/null || true)"
  elif [ "$(id -u)" -eq 0 ] && id "$agent_user" >/dev/null 2>&1; then
    version_json="$(sudo -u "$agent_user" cat "$version_file" 2>/dev/null || true)"
  fi

  if [ -z "$version_json" ]; then
    local release_target=""
    local release_sha=""

    release_target="$(readlink -f /opt/baudbot/current 2>/dev/null || true)"
    if printf '%s\n' "$release_target" | grep -Eq '/releases/[0-9a-f]{7,40}$'; then
      release_sha="${release_target##*/}"
      echo -e "${BOLD}deployed version:${RESET} ${release_sha:0:7} sha: $release_sha (from /opt/baudbot/current)"
    else
      echo -e "${BOLD}deployed version:${RESET} unavailable"
    fi
    return 0
  fi

  short="$(printf '%s\n' "$version_json" | grep -E '"short"[[:space:]]*:' | head -1 | sed 's/.*"short"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')"
  sha="$(printf '%s\n' "$version_json" | grep -E '"sha"[[:space:]]*:' | head -1 | sed 's/.*"sha"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')"
  branch="$(printf '%s\n' "$version_json" | grep -E '"branch"[[:space:]]*:' | head -1 | sed 's/.*"branch"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')"
  deployed_at="$(printf '%s\n' "$version_json" | grep -E '"deployed_at"[[:space:]]*:' | head -1 | sed 's/.*"deployed_at"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')"

  if [ -z "$short" ] && [ -n "$sha" ]; then
    short="${sha:0:7}"
  fi

  line="${short:-unknown}"
  [ -n "$branch" ] && line="$line (branch: $branch)"
  [ -n "$deployed_at" ] && line="$line deployed: $deployed_at"
  [ -n "$sha" ] && line="$line sha: $sha"

  echo -e "${BOLD}deployed version:${RESET} $line"
}

pi_control_dir() {
  local agent_user="${1:-baudbot_agent}"
  echo "/home/$agent_user/.pi/session-control"
}

pi_alias_to_uuid() {
  local alias_path="$1"
  local target

  target=$(readlink "$alias_path" 2>/dev/null || true)
  target=$(basename "$target")
  target="${target%.sock}"

  if [ -n "$target" ]; then
    echo "$target"
    return 0
  fi

  return 1
}

resolve_pi_session_id() {
  local agent_user="$1"
  local query="${2:-}"
  local dir
  local first_sock
  local matches
  local count

  dir=$(pi_control_dir "$agent_user")
  [ -d "$dir" ] || return 1

  if [ -z "$query" ]; then
    if [ -L "$dir/control-agent.alias" ]; then
      pi_alias_to_uuid "$dir/control-agent.alias"
      return 0
    fi

    first_sock=$(find "$dir" -maxdepth 1 -type s -name '*.sock' -printf '%f\n' 2>/dev/null | sort | head -1)
    if [ -n "$first_sock" ]; then
      echo "${first_sock%.sock}"
      return 0
    fi

    return 1
  fi

  # Exact UUID/socket name.
  if [ -S "$dir/$query.sock" ]; then
    echo "$query"
    return 0
  fi

  # Named alias format used by pi extensions (e.g. control-agent.alias).
  if [ -L "$dir/$query.alias" ]; then
    pi_alias_to_uuid "$dir/$query.alias"
    return 0
  fi

  # Back-compat alias format (<name>.sock symlink).
  if [ -L "$dir/$query.sock" ]; then
    pi_alias_to_uuid "$dir/$query.sock"
    return 0
  fi

  # Unique UUID prefix.
  matches=$(find "$dir" -maxdepth 1 -type s -name "$query*.sock" -printf '%f\n' 2>/dev/null | sort)
  count=$(echo "$matches" | grep -c . || true)
  if [ "$count" -eq 1 ]; then
    echo "${matches%.sock}"
    return 0
  fi
  if [ "$count" -gt 1 ]; then
    echo "❌ Multiple pi sessions match '$query'. Use full UUID or alias from: baudbot sessions" >&2
    return 2
  fi

  return 1
}

pause_before_attach() {
  if [ "${BAUDBOT_ATTACH_NO_PAUSE:-0}" = "1" ]; then
    return 0
  fi

  if [ -t 0 ] && [ -t 1 ]; then
    echo -e "${DIM}Press Enter to attach (Ctrl+C to cancel)...${RESET}"
    # shellcheck disable=SC2162
    read _
  else
    sleep 2
  fi
}

case "${1:-}" in
  install)
    shift
    bootstrap_install "$@"
    ;;

  start)
    shift
    if [ "${1:-}" = "--direct" ]; then
      # Foreground mode: run start.sh directly (for dev/CI/debugging)
      shift
      require_root "start --direct"
      exec sudo -u baudbot_agent "$BAUDBOT_ROOT/start.sh" "$@"
    else
      require_root "start"
      if has_systemd; then
        exec systemctl start baudbot "$@"
      else
        echo "systemd not available. Use: baudbot start --direct"
        exit 1
      fi
    fi
    ;;

  stop)
    shift
    require_root "stop"
    if has_systemd; then
      exec systemctl stop baudbot "$@"
    else
      echo "systemd not available. Kill the agent process manually."
      exit 1
    fi
    ;;

  restart)
    shift
    require_root "restart"
    if has_systemd; then
      exec systemctl restart baudbot "$@"
    else
      echo "systemd not available."
      exit 1
    fi
    ;;

  status)
    shift
    if has_systemd && systemctl is-enabled baudbot &>/dev/null; then
      status_rc=0
      systemctl status baudbot "$@" || status_rc=$?
      echo ""
      print_deployed_version
      exit "$status_rc"
    else
      # Fallback: check if baudbot_agent has pi running
      if pgrep -u baudbot_agent -f "pi --session-control" &>/dev/null; then
        echo "baudbot is running (no systemd unit)"
        pgrep -u baudbot_agent -af "pi --session-control"
      else
        echo "baudbot is not running"
      fi
      echo ""
      print_deployed_version
    fi
    ;;

  logs)
    shift
    if has_systemd && systemctl is-enabled baudbot &>/dev/null; then
      exec journalctl -u baudbot -f "$@"
    else
      echo "No systemd unit. Check tmux sessions:"
      echo "  sudo -u baudbot_agent tmux ls"
    fi
    ;;

  sessions)
    shift
    require_root "sessions"
    AGENT_USER="baudbot_agent"
    echo -e "${BOLD}tmux sessions:${RESET}"
    if sudo -u "$AGENT_USER" tmux ls 2>/dev/null; then
      :
    else
      echo "  (none)"
    fi
    echo ""
    echo -e "${BOLD}pi sessions:${RESET}"
    PI_CONTROL_DIR="$(pi_control_dir "$AGENT_USER")"
    if [ -d "$PI_CONTROL_DIR" ]; then
      found=0
      declare -A ALIASES

      # New alias format: <name>.alias -> <uuid>.sock
      for alias in "$PI_CONTROL_DIR"/*.alias; do
        [ -L "$alias" ] || continue
        alias_name=$(basename "$alias" .alias)
        alias_uuid=$(pi_alias_to_uuid "$alias" || true)
        [ -n "$alias_uuid" ] && ALIASES[$alias_uuid]="$alias_name"
      done

      # Back-compat alias format: <name>.sock symlink -> <uuid>.sock
      for alias in "$PI_CONTROL_DIR"/*.sock; do
        [ -L "$alias" ] || continue
        alias_name=$(basename "$alias" .sock)
        alias_uuid=$(pi_alias_to_uuid "$alias" || true)
        [ -n "$alias_uuid" ] && ALIASES[$alias_uuid]="$alias_name"
      done

      # Real socket files are UUIDs.
      for sock in "$PI_CONTROL_DIR"/*.sock; do
        [ -S "$sock" ] || continue
        [ -L "$sock" ] && continue

        sess_id=$(basename "$sock" .sock)
        name="${ALIASES[$sess_id]:-}"

        status="stopped (stale)"
        if sudo -u "$AGENT_USER" bash -c "python3 -c \"import socket; s=socket.socket(socket.AF_UNIX); s.settimeout(0.3); s.connect('$sock'); s.close()\" 2>/dev/null" 2>/dev/null; then
          status="running"
        fi

        if [ -n "$name" ]; then
          echo "  $name ($sess_id) [$status]"
        else
          echo "  $sess_id [$status]"
        fi
        found=$((found + 1))
      done

      if [ "$found" -eq 0 ]; then
        echo "  (none)"
      fi
    else
      echo "  (no session-control directory)"
    fi
    ;;

  attach)
    shift
    require_root "attach"
    AGENT_USER="baudbot_agent"
    AGENT_HOME="/home/$AGENT_USER"

    ATTACH_MODE="auto"
    TARGET=""
    while [ "$#" -gt 0 ]; do
      case "$1" in
        --pi)
          ATTACH_MODE="pi"
          shift
          ;;
        --tmux)
          ATTACH_MODE="tmux"
          shift
          ;;
        -h|--help)
          echo "Usage: sudo baudbot attach [--pi|--tmux] [session-name|session-id]"
          echo ""
          echo "Examples:"
          echo "  sudo baudbot attach                  # defaults to control-agent"
          echo "  sudo baudbot attach --pi control-agent"
          echo "  sudo baudbot attach --pi <uuid>"
          echo "  sudo baudbot attach --tmux slack-bridge"
          exit 0
          ;;
        *)
          if [ -n "$TARGET" ]; then
            echo "❌ Too many arguments for attach"
            exit 1
          fi
          TARGET="$1"
          shift
          ;;
      esac
    done

    # Default attach target should always be control-agent.
    if [ -z "$TARGET" ]; then
      TARGET="control-agent"
    fi

    attach_tmux_session() {
      local tmux_target="$1"
      echo -e "${BOLD}${CYAN}Attaching to tmux session:${RESET} $tmux_target"
      echo -e "${GREEN}Safe detach:${RESET} Ctrl+b, d ${DIM}(keeps agent running)${RESET}"
      echo ""
      pause_before_attach
      exec sudo -u "$AGENT_USER" tmux attach-session -t "$tmux_target"
    }

    attach_pi_session() {
      local pi_target="$1"
      echo -e "${BOLD}${CYAN}Attaching to pi session:${RESET} $pi_target"
      echo -e "${BOLD}${YELLOW}Safe detach (does NOT stop the agent):${RESET}"
      echo -e "  ${YELLOW}1)${RESET} Press Ctrl+C once to clear input/cancel local prompt"
      echo -e "  ${YELLOW}2)${RESET} Press Ctrl+C again to exit this client"
      echo -e "  ${GREEN}Agent keeps running under systemd in the background.${RESET}"
      echo ""
      pause_before_attach
      exec sudo -u "$AGENT_USER" bash -lc "export PATH='$AGENT_HOME/.varlock/bin:$AGENT_HOME/opt/node-v22.14.0-linux-x64/bin':\$PATH; cd ~; pi --session '$pi_target'"
    }

    choose_tmux_target() {
      local requested="${1:-}"
      local first

      if [ -n "$requested" ]; then
        if sudo -u "$AGENT_USER" tmux has-session -t "$requested" 2>/dev/null; then
          echo "$requested"
          return 0
        fi
        return 1
      fi

      first=$(sudo -u "$AGENT_USER" tmux ls -F '#{session_name}' 2>/dev/null | head -1)
      [ -n "$first" ] || return 1
      echo "$first"
      return 0
    }

    choose_pi_target() {
      local requested="${1:-}"
      local resolved

      if ! resolved=$(resolve_pi_session_id "$AGENT_USER" "$requested"); then
        return 1
      fi

      [ -n "$resolved" ] || return 1
      echo "$resolved"
      return 0
    }

    if [ "$ATTACH_MODE" = "tmux" ]; then
      if tmux_target=$(choose_tmux_target "$TARGET"); then
        attach_tmux_session "$tmux_target"
      fi
      echo "❌ tmux session not found. See: sudo baudbot sessions"
      exit 1
    fi

    if [ "$ATTACH_MODE" = "pi" ]; then
      if pi_target=$(choose_pi_target "$TARGET"); then
        attach_pi_session "$pi_target"
      fi
      echo "❌ pi session not found. See: sudo baudbot sessions"
      exit 1
    fi

    # Auto mode: prefer named pi session (control-agent by default), then tmux.
    if pi_target=$(choose_pi_target "$TARGET"); then
      attach_pi_session "$pi_target"
    fi

    if tmux_target=$(choose_tmux_target "$TARGET"); then
      attach_tmux_session "$tmux_target"
    fi

    echo "❌ No matching tmux/pi session found. See: sudo baudbot sessions"
    exit 1
    ;;

  setup)
    shift
    if [ "${1:-}" = "--slack-broker" ]; then
      shift
      require_root "broker register"
      echo "⚠️  'baudbot setup --slack-broker' is deprecated. Use: sudo baudbot broker register"
      exec node "$BAUDBOT_ROOT/bin/broker-register.mjs" "$@"
    fi
    require_root "setup"
    exec "$BAUDBOT_ROOT/setup.sh" "$@"
    ;;

  config)
    shift
    exec "$BAUDBOT_ROOT/bin/config.sh" "$@"
    ;;

  broker)
    shift
    case "${1:-}" in
      register)
        shift
        require_root "broker register"
        exec node "$BAUDBOT_ROOT/bin/broker-register.mjs" "$@"
        ;;
      --help|-h|"")
        echo "Usage: sudo baudbot broker register [--broker-url URL] [--workspace-id ID] [--auth-code CODE] [--callback-url URL]"
        ;;
      *)
        echo "Unknown broker subcommand: ${1:-}"
        echo "Usage: sudo baudbot broker register [--broker-url URL] [--workspace-id ID] [--auth-code CODE] [--callback-url URL]"
        exit 1
        ;;
    esac
    ;;

  deploy)
    shift
    require_root "deploy"
    exec "$BAUDBOT_ROOT/bin/deploy.sh" "$@"
    ;;

  audit)
    shift
    exec "$BAUDBOT_ROOT/bin/security-audit.sh" "$@"
    ;;

  test)
    shift
    exec "$BAUDBOT_ROOT/bin/test.sh" "$@"
    ;;

  update)
    shift
    require_root "update"
    exec "$BAUDBOT_ROOT/bin/update-release.sh" "$@"
    ;;

  rollback)
    shift
    require_root "rollback"
    exec "$BAUDBOT_ROOT/bin/rollback-release.sh" "$@"
    ;;

  uninstall)
    shift
    require_root "uninstall"
    exec "$BAUDBOT_ROOT/bin/uninstall.sh" "$@"
    ;;

  doctor)
    shift
    exec "$BAUDBOT_ROOT/bin/doctor.sh" "$@"
    ;;

  --version|-v)
    echo "baudbot $(version)"
    ;;

  --help|-h|"")
    usage
    ;;

  *)
    echo "Unknown command: $1"
    echo ""
    usage
    exit 1
    ;;
esac
