{
  "id": "20e26efc",
  "title": "CI job: run setup + tests on Ubuntu droplet per PR",
  "tags": [
    "infra",
    "ci",
    "ubuntu"
  ],
  "status": "todo",
  "created_at": "2026-02-17T02:30:52.375Z"
}

## Goal
Add a GitHub Actions workflow that SSHes into the DigitalOcean droplet and runs the full hornet setup + test suite on every PR.

## Depends on
- TODO-cb931656 (manual verification must pass first)

## Design decisions needed
- **Fresh state per run**: `uninstall.sh` at start of each run? Or snapshot/restore? Or ephemeral droplet via DO API?
- **Secrets**: droplet IP + SSH key stored as GitHub Actions secrets (`DROPLET_IP`, `DROPLET_SSH_KEY`)
- **Concurrency**: only one CI run at a time on the droplet (use GitHub concurrency group)
- **Scope**: full setup + test, or just test.sh (setup is slow, ~2-3 min)?

## Proposed workflow
```yaml
name: Integration (Ubuntu)
on:
  pull_request:
    branches: [main]

concurrency:
  group: droplet-integration
  cancel-in-progress: true

jobs:
  integration:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run on droplet
        env:
          DROPLET_IP: ${{ secrets.DROPLET_IP }}
          SSH_KEY: ${{ secrets.DROPLET_SSH_KEY }}
        run: |
          # SSH into droplet, rsync repo, run uninstall (clean slate),
          # run setup.sh, deploy.sh, test.sh, security-audit.sh
```

## Steps
1. Create SSH key pair for CI, add public key to droplet
2. Add `DROPLET_IP` and `DROPLET_SSH_KEY` as GitHub repo secrets
3. Write the workflow file (`.github/workflows/integration.yml`)
4. Handle cleanup: uninstall.sh at start of run for clean state
5. Fail the PR if any step exits non-zero
6. Consider: also run security-audit.sh (some checks need live system)

## Open questions
- Do we want to spin up/destroy droplets per run (more isolated, costs more) or reuse one?
- Should we test `start.sh` actually booting an agent, or just setup + unit tests?
